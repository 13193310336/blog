---
title: pcntl-1
date: 2018-12-24 02:20:00
categories:
 - php
 - pcntl
tags: 
 - php
 - pcntl
---

**pcntl_fork()**

- 官方解释
 	在当前进程当前位置产生分支（子进程）。译注：是创建了一个子进程，父进程和子进程 都从fork的位置开始向下继续执行，不同的是父进程执行过程中，得到的fork返回值为子进程 号，而子进程得到的是0

- 函数返回值  
	函数返回三中值：-1， 0， 大于0的整数
	-  -1: 子进程创建失败
	- 0:当子进程创建成功时，返回0时说明当前进程是子进程
	- 大于0整数:当前子进程创建成功时，返回大于0的整数说明当前进程时父进程，并且该整数就是父进程的PID

- 提示
	创建的子进程完完整整复制父进程的堆栈资源，相当于父进程的一个独立副本，然后父子进程都从父进程fork的地方继续向下执行代码；所以，如果父进程是循环创建的子进程, 那么子进程执行完毕不退出的话也会继续执行父进程剩下的循环（pcntl_fork()调用后剩下的循环），也就是说子进程又会创建子进程，所以，如果希望子进程只处理特殊任务（如发送邮件），那么子进程执行完毕后应该主动退出）
	
- 代码示例
	

``` php
	//example
	for($i = 1; $i <= 2; $i ++) {
		$pid = pcntl_fork();
		if ($pid == -1) {
			\Component\out('子进程创建失败');
		} else {
			if ($pid) {
				\Component\out('父进程已创建子进程' . $pid);
			} else {
				\Component\out('子进程' . getmypid() . '运行完毕');
			}
		}
	}
	//output
	父进程已创建子进程22831
	子进程22831运行完毕
	父进程已创建子进程22832
	子进程22832运行完毕
	父进程已创建子进程22834
	子进程22834运行完毕
```
*我们代码明明创建了两个进程，为什么程序会创建3个呢？原因在上面提示中说了，子进程会在父进程fork后的地方执行代码，由于子进程中没有退出代码，子进程执行完毕后会继续执行复制与父进程的主逻辑代码，所以当$i=1的时候，循环不满足退出条件还有一次循环（也就是$i=2），此时创建的子进程没有退出继续执行了剩下的一层循环，所以一共创建了三个进程，循环次数越多，子进程数量越不可控，代码更改为如下*

``` php
	//example
	for($i = 1; $i <= 2; $i ++) {
		$pid = pcntl_fork();
		if ($pid == -1) {
			\Component\out('子进程创建失败');
		} else {
			if ($pid) {
				\Component\out('父进程已创建子进程' . $pid);
			} else {
				\Component\out('子进程' . getmypid() . '运行完毕');
				exit();
			}
		}
	}
	//output
	父进程已创建子进程23018
	子进程23018运行完毕
	父进程已创建子进程23019
	子进程23019运行完毕
```
*子进程添加退出代码，不会再跑去执行主逻辑代码*

----------

**pcntl_wait()**

- 官方解释
	*wait函数刮起当前进程的执行直到一个子进程退出或接收到一个信号要求中断当前进程或调用一个信号处理函数。 如果一个子进程在调用此函数时已经退出（俗称僵尸进程），此函数立刻返回。子进程使用的所有系统资源将 被释放。*

- 函数参数
	函数有两个参数$status和$options
	- $status 子进程的状态信息，可以通过状态分析函数pcntl_wifexited(), pcntl_wifstopped()...等分析子进程的退出状态,以便进行相应的逻辑处理。
	- $option 此参数主要用来设置函数的运行方式（阻塞OR非阻塞，默认阻塞）

- 函数返回值
	函数返回三中值：-1， 0， 大于0的整数
	-  -1: 发生错误
	- 0:如果第二个参数option设置为常量WNOHANG(值为1)并且没有得到退出子进程时返回
	- 大于0整数:退出的子进程PID

- 提示
	*在多进程中经常会出现僵尸进程（就是子进程执行完毕，并没有正常退出，所以一直占用系统资源，一个两个当然无所谓，但如果动态创建进程的话那就很可怕了），此函数的主要作用就是用来保证子函数的运行状态*
	
- 代码示例
	

``` php
	//example
	for($i = 1; $i <= 10; $i ++) {
		$pid = pcntl_fork();
		if ($pid == -1) {
			\Component\out('子进程创建失败');
		} else {
			if ($pid) {
				\Component\out('父进程已创建子进程' . $pid);
				pcntl_wait($status);
			} else {
				sleep(10);
				\Component\out('子进程' . getmypid() . '运行完毕');
				exit();
			}
		}
	}
	
	//运行后第一秒已输出如下:
	php start.php 
	父进程已创建子进程24536(停顿10秒)
	
	//运行完毕后输出如下:
	php start.php
	父进程已创建子进程24536(停顿10秒)
	子进程24536运行完毕
	父进程已创建子进程24538(停顿10秒)
	子进程24538运行完毕
	父进程已创建子进程24543(停顿10秒)
	子进程24543运行完毕
	父进程已创建子进程24546(停顿10秒)
	子进程24546运行完毕
	父进程已创建子进程24549(停顿10秒)
	子进程24549运行完毕
	父进程已创建子进程24550(停顿10秒)
	子进程24550运行完毕
	父进程已创建子进程24553(停顿10秒)
	子进程24553运行完毕
	父进程已创建子进程24557(停顿10秒)
	子进程24557运行完毕
	父进程已创建子进程24564(停顿10秒)
	子进程24564运行完毕
	父进程已创建子进程24567(停顿10秒)
	子进程24567运行完毕

```
*因为pcntl_wait()函数默认是阻塞执行的，所以只有当前一个子进程执行完毕后才会创建下一个子进程，对于需要多进程提高性能的应用来说，这样的多进程是无意义的，因为说到底还是阻塞，并没有提高程序性能，所以需要给pcntl_wait函数设置第二个参数为常量WNOHANG(实际值为1)，让其不阻塞运行，不过如果这样的话第一个参数$status就变成0了,这是后话，后面会提到，当前示例如下*

``` php
	//example
	for($i = 1; $i <= 10; $i ++) {
		$pid = pcntl_fork();
		if ($pid == -1) {
			\Component\out('子进程创建失败');
		} else {
			if ($pid) {
				\Component\out('父进程已创建子进程' . $pid);
				pcntl_wait($status, WNOHANG);
			} else {
				sleep(10);
				\Component\out('子进程' . getmypid() . '运行完毕');
				exit();
			}
		}
	}
	
	//运行后第一秒已输出如下:
	php start.php
	父进程已创建子进程24837
	父进程已创建子进程24838
	父进程已创建子进程24839
	父进程已创建子进程24840
	父进程已创建子进程24841
	父进程已创建子进程24842
	父进程已创建子进程24843
	父进程已创建子进程24844
	父进程已创建子进程24845
	父进程已创建子进程24846
	
	//运行完毕后输出如下:
	php start.php
	父进程已创建子进程24837
	父进程已创建子进程24838
	父进程已创建子进程24839
	父进程已创建子进程24840
	父进程已创建子进程24841
	父进程已创建子进程24842
	父进程已创建子进程24843
	父进程已创建子进程24844
	父进程已创建子进程24845
	父进程已创建子进程24846（停顿10秒）
	子进程24837运行完毕
	子进程24838运行完毕
	子进程24839运行完毕
	子进程24840运行完毕
	子进程24841运行完毕
	子进程24842运行完毕
	子进程24843运行完毕
	子进程24844运行完毕
	子进程24845运行完毕
	子进程24846运行完毕
	
```
*这样程序运行的时间就等于所有子进程中耗时最长的子进程时间，这是第二个参数的用法，接下来看下第一个参数的意义*

``` stylus
	
	//example
	for($i = 1; $i <= 10; $i ++) {
		$pid = pcntl_fork();
		if ($pid == -1) {
			\Component\out('子进程创建失败');
		} else {
			if ($pid) {
				\Component\out('父进程已创建子进程' . $pid);
				pcntl_wait($status);
				if (pcntl_wifexited($status))
					\Component\out('子进程' . $pid . '正常退出');
				else
					\Component\out('子进程' . $pid . '异常退出');
			} else {
				sleep(30);
				\Component\out('子进程' .getmypid() . '运行完毕');
				exit();
			}
		}
	}
	
	//第一秒运行输出如下
	php start.php
	父进程已创建子进程25147（此处正常应该停顿30秒）
	
	//新建控制台输入如下
	kill 25147
	
	//此时运行程序立即输出如下
	子进程25147异常退出
	
	//程序运行完毕如下
	父进程已创建子进程25147
	子进程25147异常退出
	父进程已创建子进程25149
	子进程25149运行完毕
	子进程25149正常退出
	父进程已创建子进程25153
	子进程25153运行完毕
	子进程25153正常退出
	父进程已创建子进程25161
	子进程25161运行完毕
	子进程25161正常退出
	父进程已创建子进程25237
	子进程25237运行完毕
	子进程25237正常退出
	父进程已创建子进程25247
	子进程25247运行完毕
	子进程25247正常退出
	父进程已创建子进程25251
	子进程25251运行完毕
	子进程25251正常退出
	父进程已创建子进程25257
	子进程25257运行完毕
	子进程25257正常退出
	父进程已创建子进程25271
	子进程25271运行完毕
	子进程25271正常退出
	父进程已创建子进程25278
	子进程25278运行完毕
	子进程25278正常退出
	
```
*上面也说过，$status就是用于状态分析函数来判断退出结果的，示例中的pcntl_wifexited()函数是判断子进程是否正常退出，阻塞时可以这样判断，但是非阻塞时呢？此时wait函数会立即返回，因为代码不出问题的话一般不会有退出的子进程，所以通常拿到的值都是0，那么怎么处理呢？此时就需要用到一个新函数pcntl_waitpid()了，此函数跟pcntl_wait函数大同小异，在此就不过多解释了，[pcntl_waitpid详情][1]，看代码吧*

``` php
	$pidCollection = [];
	//example
	for($i = 1; $i <= 10; $i ++) {
		$pid = pcntl_fork();
		if ($pid == -1) {
			\Component\out('子进程创建失败');
		} else {
			if ($pid) {
				\Component\out('父进程已创建子进程' . $pid);

            //此处必定返回0，所以此段if判断毫无意义，此处只是示例便于理解，正经非阻塞判断方法应该是下面while循环中的方法，所以此段代码应该直接删除掉
            if (pcntl_wait($status, WNOHANG)) {
                if (pcntl_wifexited($status))
                    \Component\out('子进程' . $pid . '正常退出');
                else
                    \Component\out('子进程' . $pid . '异常退出');
            }

				$pidCollection[$pid] = $pid;
			} else {
				sleep(30);
				\Component\out('子进程' . getmypid() . '运行完毕');
				exit();
			}
		}
	}

	while ($pidCollection) {
		//第一个参数-1表示监听当前进程所有子进程，后两个参数跟pcntl_fork函数无区别
		$pid = pcntl_waitpid(-1, $status, WNOHANG);
		if (!$pid) {
			sleep(1);
		} else {
			if (pcntl_wifexited($status))
				\Component\out('子进程' . $pid . '正常退出');
			else
				\Component\out('子进程' . $pid . '异常退出');
			unset($pidCollection[$pid]);
		}
	}
	
	//第一秒运行输出如下
	php start.php 
	父进程已创建子进程27441
	父进程已创建子进程27442
	父进程已创建子进程27443
	父进程已创建子进程27444
	父进程已创建子进程27445
	父进程已创建子进程27446
	父进程已创建子进程27447
	父进程已创建子进程27448
	父进程已创建子进程27449
	父进程已创建子进程27450

	//新建控制台输入如下（我们这次挑第三个欺负，老欺负第一个不太公平）
	kill 27443
	
	//此时运行程序立即输出如下
	子进程27443异常退出

	//程序运行完毕如下
	父进程已创建子进程27441
	父进程已创建子进程27442
	父进程已创建子进程27443
	父进程已创建子进程27444
	父进程已创建子进程27445
	父进程已创建子进程27446
	父进程已创建子进程27447
	父进程已创建子进程27448
	父进程已创建子进程27449
	父进程已创建子进程27450
	子进程27443异常退出
	子进程27441运行完毕
	子进程27442运行完毕
	子进程27444运行完毕
	子进程27445运行完毕
	子进程27446运行完毕
	子进程27447运行完毕
	子进程27448运行完毕
	子进程27449运行完毕
	子进程27450运行完毕
	子进程27441正常退出
	子进程27442正常退出
	子进程27444正常退出
	子进程27445正常退出
	子进程27446正常退出
	子进程27447正常退出
	子进程27448正常退出
	子进程27449正常退出
	子进程27450正常退出
```
*pcntl_wait在非阻塞程序中无实际意义，非阻塞程序状态监听我们使用pcntl_waitpid函数通过轮训来分析子进程状态*


- 常用状态分析函数
	 - pcntl_wifexited() 检查状态代码是否代表一个正常的退出。
	 - pcntl_wifstopped() 检查子进程当前是否已经停止
	 - pcntl_wifsignaled() 检查子进程状态码是否代表由于某个信号而中断
	 - pcntl_wexitstatus() 返回一个中断的子进程的返回代码
	 - pcntl_wtermsig() 返回导致子进程中断的信号
	 - pcntl_wstopsig()返回导致子进程停止的信号


----------
 
> 到此，PCNTL扩展基础分享就此结束，如有不妥之处，敬请留言回复以便更正，防止误导他人；漫漫码路，与君共勉！

  [1]: http://php.net/manual/zh/function.pcntl-waitpid.php

